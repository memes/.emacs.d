# Hibernate Mapping DTD.
# 
# <!DOCTYPE hibernate-mapping PUBLIC 
#	"-//Hibernate/Hibernate Mapping DTD 2.0//EN"
#	"http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd">
# 
# An instance of this XML document may contain mappings for an arbitrary 
# number of classes. The class mappings may contain associations to classes
# mapped in the same document or in another document. No class may be 
# mapped more than once. Each document may also contain definitions of an
# arbitrary number of queries, and import declarations of arbitrary classes. 
#

# The document root.

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

hibernate-mapping =
  element hibernate-mapping {
    attlist.hibernate-mapping,
    meta*,
    import*,
    (class | subclass | joined-subclass)*,
    query*,
    sql-query*
  }
attlist.hibernate-mapping &= attribute schema { text }?
# default: none
attlist.hibernate-mapping &=
  [ a:defaultValue = "none" ]
  attribute default-cascade { "none" | "save-update" | "all" }?
attlist.hibernate-mapping &=
  [ a:defaultValue = "property" ] attribute default-access { text }?
attlist.hibernate-mapping &=
  [ a:defaultValue = "true" ]
  attribute auto-import { "true" | "false" }?
attlist.hibernate-mapping &= attribute package { text }?
# default: none

# An explicit query language "import"
import = element import { attlist.import, empty }
attlist.import &= attribute class { text }
attlist.import &= attribute rename { text }?
# default: unqualified class name

# Root of an entity class hierarchy. Entities have their own tables.
class =
  element class {
    attlist.class,
    meta*,
    (cache | jcs-cache)?,
    (id | composite-id),
    discriminator?,
    (version | timestamp)?,
    (property
     | many-to-one
     | one-to-one
     | component
     | dynamic-component
     | any
     | map
     | set
     | \list
     | bag
     | idbag
     | array
     | primitive-array)*,
    (subclass* | joined-subclass*)
  }
attlist.class &= attribute name { text }
attlist.class &= attribute table { text }?
# default: unqualified classname
attlist.class &= attribute schema { text }?
# default: none
attlist.class &= attribute proxy { text }?
# default: no proxy interface
attlist.class &= attribute discriminator-value { text }?
# default: unqualified class name | none
attlist.class &=
  [ a:defaultValue = "true" ] attribute mutable { "true" | "false" }?
attlist.class &=
  [ a:defaultValue = "implicit" ]
  attribute polymorphism { "implicit" | "explicit" }?
attlist.class &= attribute where { text }?
# default: none
attlist.class &= attribute persister { text }?
attlist.class &=
  [ a:defaultValue = "false" ]
  attribute dynamic-update { "true" | "false" }?
attlist.class &=
  [ a:defaultValue = "false" ]
  attribute dynamic-insert { "true" | "false" }?
attlist.class &= [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.class &=
  [ a:defaultValue = "false" ]
  attribute select-before-update { "true" | "false" }?
attlist.class &=
  [ a:defaultValue = "version" ]
  attribute optimistic-lock { "none" | "version" | "dirty" | "all" }?
attlist.class &= attribute lazy { "true" | "false" }?
attlist.class &= attribute check { text }?
# default: none

# Declares the id type, column and generation algorithm for an entity class.
# If a name attribut is given, the id is exposed to the application through the 
# named property of the class. If not, the id is only exposed to the application 
# via Session.getIdentifier()
id = element id { attlist.id, meta*, column*, generator }
attlist.id &= attribute name { text }?
attlist.id &= attribute access { text }?
attlist.id &= attribute column { text }?
attlist.id &= attribute type { text }?
attlist.id &= attribute length { text }?
attlist.id &=
  [ a:defaultValue = "null" ] attribute unsaved-value { text }?
# any|none|null|0|-1|...

# A composite key may be modelled by a java class with a property for each 
# key column. The class must implement java.io.Serializable and reimplement equals() 
# and hashCode().
composite-id =
  element composite-id {
    attlist.composite-id, meta*, (key-property | key-many-to-one)+
  }
attlist.composite-id &= attribute class { text }?
attlist.composite-id &= attribute name { text }?
attlist.composite-id &= attribute access { text }?
attlist.composite-id &=
  [ a:defaultValue = "none" ]
  attribute unsaved-value { "any" | "none" }?
# Polymorphic data requires a column holding a class discriminator value. This
# value is not directly exposed to the application.
discriminator = element discriminator { attlist.discriminator, column? }
attlist.discriminator &= attribute column { text }?
# default: "class"|none
attlist.discriminator &=
  [ a:defaultValue = "string" ] attribute type { text }?
attlist.discriminator &=
  [ a:defaultValue = "true" ] attribute not-null { "true" | "false" }?
attlist.discriminator &= attribute length { text }?
attlist.discriminator &=
  [ a:defaultValue = "false" ] attribute force { "true" | "false" }?
attlist.discriminator &=
  [ a:defaultValue = "true" ] attribute insert { "true" | "false" }?
# Versioned data requires a column holding a version number. This is exposed to the
# application through a property of the Java class.
version = element version { attlist.version, meta* }
attlist.version &= attribute name { text }
attlist.version &= attribute access { text }?
attlist.version &= attribute column { text }?
attlist.version &=
  [ a:defaultValue = "integer" ] attribute type { text }?
attlist.version &=
  [ a:defaultValue = "undefined" ]
  attribute unsaved-value { "null" | "negative" | "undefined" }?
timestamp = element timestamp { attlist.timestamp, meta* }
attlist.timestamp &= attribute name { text }
attlist.timestamp &= attribute column { text }?
attlist.timestamp &= attribute access { text }?
attlist.timestamp &=
  [ a:defaultValue = "null" ]
  attribute unsaved-value { "null" | "undefined" }?
# Subclass declarations are nested beneath the root class declaration to achieve
# polymorphic persistence.
subclass =
  element subclass {
    attlist.subclass,
    meta*,
    (property
     | many-to-one
     | one-to-one
     | component
     | dynamic-component
     | any
     | map
     | set
     | \list
     | bag
     | idbag
     | array
     | primitive-array)*,
    subclass*
  }
attlist.subclass &= attribute name { text }
attlist.subclass &= attribute proxy { text }?
# default: no proxy interface
attlist.subclass &= attribute discriminator-value { text }?
# default: unqualified class name | none
attlist.subclass &=
  [ a:defaultValue = "false" ]
  attribute dynamic-update { "true" | "false" }?
attlist.subclass &=
  [ a:defaultValue = "false" ]
  attribute dynamic-insert { "true" | "false" }?
attlist.subclass &=
  [ a:defaultValue = "false" ]
  attribute select-before-update { "true" | "false" }?
attlist.subclass &= attribute extends { text }?
# default: empty when a toplevel, otherwise the nearest class definition
attlist.subclass &= attribute lazy { "true" | "false" }?
attlist.subclass &= attribute persister { text }?
# Joined subclasses are used for the normalized table-per-subclass mapping strategy
joined-subclass =
  element joined-subclass {
    attlist.joined-subclass,
    meta*,
    key,
    (property
     | many-to-one
     | one-to-one
     | component
     | dynamic-component
     | any
     | map
     | set
     | \list
     | bag
     | idbag
     | array
     | primitive-array)*,
    joined-subclass*
  }
attlist.joined-subclass &= attribute name { text }
attlist.joined-subclass &= attribute proxy { text }?
# default: no proxy interface
attlist.joined-subclass &= attribute table { text }?
# default: unqualified class name
attlist.joined-subclass &= attribute schema { text }?
attlist.joined-subclass &=
  [ a:defaultValue = "false" ]
  attribute dynamic-update { "true" | "false" }?
attlist.joined-subclass &=
  [ a:defaultValue = "false" ]
  attribute dynamic-insert { "true" | "false" }?
attlist.joined-subclass &=
  [ a:defaultValue = "false" ]
  attribute select-before-update { "true" | "false" }?
attlist.joined-subclass &= attribute extends { text }?
# default: empty when a toplevel, otherwise the nearest class definition
attlist.joined-subclass &= attribute lazy { "true" | "false" }?
attlist.joined-subclass &= attribute persister { text }?
attlist.joined-subclass &= attribute check { text }?
# default: none

# Property of an entity class or component, component-element, composite-id, etc. 
# JavaBeans style properties are mapped to table columns.
property = element property { attlist.property, meta*, column* }
attlist.property &= attribute name { text }
attlist.property &= attribute access { text }?
attlist.property &= attribute type { text }?
attlist.property &= attribute column { text }?
attlist.property &= attribute length { text }?
attlist.property &=
  [ a:defaultValue = "false" ] attribute not-null { "true" | "false" }?
attlist.property &=
  [ a:defaultValue = "false" ] attribute unique { "true" | "false" }?
attlist.property &=
  [ a:defaultValue = "true" ] attribute update { "true" | "false" }?
# only supported for properties of a class (not component)
attlist.property &=
  [ a:defaultValue = "true" ] attribute insert { "true" | "false" }?
# only supported for properties of a class (not component)
attlist.property &= attribute formula { text }?
# only supported for properties of a class (not component)
attlist.property &= attribute index { text }?
# include the columns spanned by this property in an index

# Declares an association between two entities (Or from a component, component element,
# etc. to an entity).
many-to-one =
  element many-to-one { attlist.many-to-one, meta*, column* }
attlist.many-to-one &= attribute name { text }
attlist.many-to-one &= attribute access { text }?
attlist.many-to-one &= attribute class { text }?
attlist.many-to-one &= attribute column { text }?
attlist.many-to-one &=
  [ a:defaultValue = "false" ] attribute not-null { "true" | "false" }?
attlist.many-to-one &=
  [ a:defaultValue = "false" ] attribute unique { "true" | "false" }?
attlist.many-to-one &=
  attribute cascade { "none" | "all" | "save-update" | "delete" }?
# default: none
attlist.many-to-one &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.many-to-one &=
  [ a:defaultValue = "true" ] attribute update { "true" | "false" }?
# only supported for many-to-one of a class (not component)
attlist.many-to-one &=
  [ a:defaultValue = "true" ] attribute insert { "true" | "false" }?
# only supported for many-to-one of a class (not component)
attlist.many-to-one &= attribute foreign-key { text }?
attlist.many-to-one &= attribute property-ref { text }?
attlist.many-to-one &= attribute index { text }?
# include the columns spanned by this association in an index

# Declares a one-to-one association between two entities (Or from a component, 
# component element, etc. to an entity).
one-to-one = element one-to-one { attlist.one-to-one, meta* }
attlist.one-to-one &= attribute name { text }
attlist.one-to-one &= attribute access { text }?
attlist.one-to-one &= attribute class { text }?
attlist.one-to-one &=
  attribute cascade { "none" | "all" | "save-update" | "delete" }?
# default: none
attlist.one-to-one &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.one-to-one &=
  [ a:defaultValue = "false" ]
  attribute constrained { "true" | "false" }?
attlist.one-to-one &= attribute foreign-key { text }?
attlist.one-to-one &= attribute property-ref { text }?
# A property embedded in a composite identifier or map index (always not-null).
key-property =
  element key-property { attlist.key-property, meta*, column* }
attlist.key-property &= attribute name { text }
attlist.key-property &= attribute access { text }?
attlist.key-property &= attribute type { text }?
attlist.key-property &= attribute column { text }?
attlist.key-property &= attribute length { text }?
# A many-to-one association embedded in a composite identifier or map index 
# (always not-null, never cascade).
key-many-to-one =
  element key-many-to-one { attlist.key-many-to-one, meta*, column* }
attlist.key-many-to-one &= attribute name { text }
attlist.key-many-to-one &= attribute access { text }?
attlist.key-many-to-one &= attribute class { text }?
attlist.key-many-to-one &= attribute column { text }?
attlist.key-many-to-one &= attribute foreign-key { text }?
# An "any" association is a polymorphic association to any table with
# the given identifier type. The first listed column is a VARCHAR column 
# holding the name of the class (for that row).
any = element any { attlist.any, meta*, meta-value*, column, column+ }
attlist.any &= attribute id-type { text }
attlist.any &= attribute meta-type { text }?
# - default: Hibernate.CLASS
attlist.any &= attribute name { text }
attlist.any &= attribute access { text }?
attlist.any &=
  [ a:defaultValue = "true" ] attribute insert { "true" | "false" }?
# only supported for many-to-one of a class (not component)
attlist.any &=
  [ a:defaultValue = "true" ] attribute update { "true" | "false" }?
# only supported for many-to-one of a class (not component)
attlist.any &=
  [ a:defaultValue = "none" ]
  attribute cascade { "none" | "save-update" | "all" }?
attlist.any &= attribute index { text }?
# include the columns spanned by this association in an index
meta-value = element meta-value { attlist.meta-value, empty }
attlist.meta-value &= attribute value { text }
attlist.meta-value &= attribute class { text }
# A component is a user-defined class, persisted along with its containing entity
# to the table of the entity class. JavaBeans style properties of the component are
# mapped to columns of the table of the containing entity. A null component reference
# is mapped to null values in all columns and vice versa. Components do not support
# shared reference semantics.
component =
  element component {
    attlist.component,
    meta*,
    \parent?,
    (property
     | many-to-one
     | one-to-one
     | component
     | dynamic-component
     | any
     | map
     | set
     | \list
     | bag
     | array
     | primitive-array)*
  }
attlist.component &= attribute class { text }?
attlist.component &= attribute name { text }
attlist.component &= attribute access { text }?
attlist.component &=
  [ a:defaultValue = "true" ] attribute update { "true" | "false" }?
attlist.component &=
  [ a:defaultValue = "true" ] attribute insert { "true" | "false" }?
dynamic-component =
  element dynamic-component {
    attlist.dynamic-component,
    (property
     | many-to-one
     | one-to-one
     | component
     | dynamic-component
     | any
     | map
     | set
     | \list
     | bag
     | array
     | primitive-array)*
  }
attlist.dynamic-component &= attribute name { text }
attlist.dynamic-component &= attribute access { text }?
attlist.dynamic-component &=
  [ a:defaultValue = "true" ] attribute update { "true" | "false" }?
attlist.dynamic-component &=
  [ a:defaultValue = "true" ] attribute insert { "true" | "false" }?
# The parent element maps a property of the component class as a pointer back to
# the owning entity.
\parent = element parent { attlist.parent, empty }
attlist.parent &= attribute name { text }
# Collection declarations nested inside a class declaration indicate a foreign key 
# relationship from the collection table to the enclosing class.
map =
  element map {
    attlist.map,
    meta*,
    (cache | jcs-cache)?,
    key,
    (index | composite-index | index-many-to-many | index-many-to-any),
    (\element
     | one-to-many
     | many-to-many
     | composite-element
     | many-to-any)
  }
attlist.map &= attribute name { text }
attlist.map &= attribute access { text }?
attlist.map &= attribute table { text }?
# default: name
attlist.map &= attribute schema { text }?
# default: none
attlist.map &=
  [ a:defaultValue = "false" ] attribute lazy { "true" | "false" }?
attlist.map &=
  [ a:defaultValue = "false" ] attribute inverse { "true" | "false" }?
attlist.map &= [ a:defaultValue = "unsorted" ] attribute sort { text }?
# unsorted|natural|"comparator class", default: unsorted
attlist.map &=
  attribute cascade {
    "none"
    | "all"
    | "save-update"
    | "delete"
    | "all-delete-orphan"
    | "delete-orphan"
  }?
# default: none
attlist.map &= attribute order-by { text }?
# default: none
attlist.map &= attribute where { text }?
# default: none
attlist.map &= [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.map &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.map &= attribute check { text }?
# default: none
attlist.map &= attribute persister { text }?
set =
  element set {
    attlist.set,
    meta*,
    (cache | jcs-cache)?,
    key,
    (\element
     | one-to-many
     | many-to-many
     | composite-element
     | many-to-any)
  }
attlist.set &= attribute name { text }
attlist.set &= attribute access { text }?
attlist.set &= attribute table { text }?
# default: name
attlist.set &= attribute schema { text }?
# default: none
attlist.set &=
  [ a:defaultValue = "false" ] attribute lazy { "true" | "false" }?
attlist.set &= [ a:defaultValue = "unsorted" ] attribute sort { text }?
# unsorted|natural|"comparator class"
attlist.set &=
  [ a:defaultValue = "false" ] attribute inverse { "true" | "false" }?
attlist.set &=
  attribute cascade {
    "none"
    | "all"
    | "save-update"
    | "delete"
    | "all-delete-orphan"
    | "delete-orphan"
  }?
# default: none
attlist.set &= attribute order-by { text }?
# default: none
attlist.set &= attribute where { text }?
# default: none
attlist.set &= [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.set &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.set &= attribute persister { text }?
attlist.set &= attribute check { text }?
# default: none
bag =
  element bag {
    attlist.bag,
    meta*,
    (cache | jcs-cache)?,
    key,
    (\element
     | one-to-many
     | many-to-many
     | composite-element
     | many-to-any)
  }
attlist.bag &= attribute name { text }
attlist.bag &= attribute access { text }?
attlist.bag &= attribute table { text }?
# default: name
attlist.bag &= attribute schema { text }?
# default: none
attlist.bag &=
  [ a:defaultValue = "false" ] attribute lazy { "true" | "false" }?
attlist.bag &=
  [ a:defaultValue = "false" ] attribute inverse { "true" | "false" }?
attlist.bag &=
  attribute cascade {
    "none"
    | "all"
    | "save-update"
    | "delete"
    | "all-delete-orphan"
    | "delete-orphan"
  }?
# default: none
attlist.bag &= attribute order-by { text }?
# default: none
attlist.bag &= attribute where { text }?
# default: none
attlist.bag &= [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.bag &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.bag &= attribute persister { text }?
attlist.bag &= attribute check { text }?
# default: none
idbag =
  element idbag {
    attlist.idbag,
    meta*,
    (cache | jcs-cache)?,
    collection-id,
    key,
    (\element | many-to-many | composite-element | many-to-any)
  }
attlist.idbag &= attribute name { text }
attlist.idbag &= attribute access { text }?
attlist.idbag &= attribute table { text }?
# default: name
attlist.idbag &= attribute schema { text }?
# default: none
attlist.idbag &=
  [ a:defaultValue = "false" ] attribute lazy { "true" | "false" }?
attlist.idbag &=
  attribute cascade {
    "none"
    | "all"
    | "save-update"
    | "delete"
    | "all-delete-orphan"
    | "delete-orphan"
  }?
# default: none
attlist.idbag &= attribute order-by { text }?
# default: none
attlist.idbag &= attribute where { text }?
# default: none
attlist.idbag &= [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.idbag &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.idbag &= attribute persister { text }?
attlist.idbag &= attribute check { text }?
# default: none
\list =
  element list {
    attlist.list,
    meta*,
    (cache | jcs-cache)?,
    key,
    index,
    (\element
     | one-to-many
     | many-to-many
     | composite-element
     | many-to-any)
  }
attlist.list &= attribute name { text }
attlist.list &= attribute access { text }?
attlist.list &= attribute table { text }?
# default: name
attlist.list &= attribute schema { text }?
# default: none
attlist.list &=
  [ a:defaultValue = "false" ] attribute lazy { "true" | "false" }?
attlist.list &=
  [ a:defaultValue = "false" ] attribute inverse { "true" | "false" }?
attlist.list &=
  attribute cascade {
    "none"
    | "all"
    | "save-update"
    | "delete"
    | "all-delete-orphan"
    | "delete-orphan"
  }?
# default: none
attlist.list &= attribute where { text }?
# default: none
attlist.list &= [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.list &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.list &= attribute persister { text }?
attlist.list &= attribute check { text }?
# default: none
array =
  element array {
    attlist.array,
    meta*,
    (cache | jcs-cache)?,
    key,
    index,
    (\element
     | one-to-many
     | many-to-many
     | composite-element
     | many-to-any)
  }
attlist.array &= attribute name { text }
attlist.array &= attribute access { text }?
attlist.array &= attribute table { text }?
# default: name
attlist.array &= attribute schema { text }?
# default: none
attlist.array &=
  [ a:defaultValue = "false" ] attribute inverse { "true" | "false" }?
attlist.array &= attribute element-class { text }?
attlist.array &=
  attribute cascade { "none" | "all" | "save-update" | "delete" }?
# default: none
attlist.array &= attribute where { text }?
# default: none
attlist.array &= [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.array &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.array &= attribute persister { text }?
attlist.array &= attribute check { text }?
# default: none
primitive-array =
  element primitive-array {
    attlist.primitive-array,
    meta*,
    (cache | jcs-cache)?,
    key,
    index,
    \element
  }
attlist.primitive-array &= attribute name { text }
attlist.primitive-array &= attribute access { text }?
attlist.primitive-array &= attribute table { text }?
# default: name
attlist.primitive-array &= attribute schema { text }?
# default: none
attlist.primitive-array &= attribute where { text }?
# default: none
attlist.primitive-array &=
  [ a:defaultValue = "1" ] attribute batch-size { text }?
attlist.primitive-array &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.primitive-array &= attribute persister { text }?
attlist.primitive-array &= attribute check { text }?
# default: none

# Declares the element type of a collection of basic type
\element = element element { attlist.element, column* }
attlist.element &= attribute column { text }?
attlist.element &= attribute type { text }
attlist.element &= attribute length { text }?
attlist.element &=
  [ a:defaultValue = "false" ] attribute not-null { "true" | "false" }?
attlist.element &=
  [ a:defaultValue = "false" ] attribute unique { "true" | "false" }?
# One to many association. This tag declares the entity-class
# element type of a collection and specifies a one-to-many relational model
one-to-many = element one-to-many { attlist.one-to-many, empty }
attlist.one-to-many &= attribute class { text }
#  No column declaration attributes required in this case. The primary
# key column of the associated class is already mapped elsewhere.

# Many to many association. This tag declares the entity-class
# element type of a collection and specifies a many-to-many relational model
many-to-many =
  element many-to-many { attlist.many-to-many, meta*, column* }
attlist.many-to-many &= attribute class { text }
attlist.many-to-many &= attribute column { text }?
attlist.many-to-many &=
  [ a:defaultValue = "auto" ]
  attribute outer-join { "true" | "false" | "auto" }?
attlist.many-to-many &= attribute foreign-key { text }?
# unique makes no sense here since it would make the association one-to-many

# A composite element allows a collection to hold instances of an arbitrary 
# class, without the requirement of joining to an entity table. Composite elements
# have component semantics - no shared references and ad hoc null value semantics. 
# Composite elements may not hold nested collections.
composite-element =
  element composite-element {
    attlist.composite-element,
    meta*,
    \parent?,
    (property | many-to-one | any | nested-composite-element)*
  }
attlist.composite-element &= attribute class { text }
nested-composite-element =
  element nested-composite-element {
    attlist.nested-composite-element,
    meta*,
    \parent?,
    (property | many-to-one | any | nested-composite-element)*
  }
attlist.nested-composite-element &= attribute class { text }
attlist.nested-composite-element &= attribute name { text }
attlist.nested-composite-element &= attribute access { text }?
# Declares the column name of a foreign key.
key = element key { attlist.key, column* }
attlist.key &= attribute column { text }?
attlist.key &= attribute foreign-key { text }?
# Declares the type and column mapping for a collection index (array or
# list index, or key of a map).
index = element index { attlist.index, column* }
attlist.index &= attribute column { text }?
attlist.index &= attribute type { text }?
# required for maps
attlist.index &= attribute length { text }?
# Many to many association mapped to the key of a map. ie. a map keyed
# on entities.
index-many-to-many =
  element index-many-to-many { attlist.index-many-to-many, column* }
attlist.index-many-to-many &= attribute class { text }
attlist.index-many-to-many &= attribute column { text }?
attlist.index-many-to-many &= attribute foreign-key { text }?
# Composite index of a map ie. a map keyed on components.
composite-index =
  element composite-index {
    attlist.composite-index, (key-property | key-many-to-one)+
  }
attlist.composite-index &= attribute class { text }
# A "many to any" defines a polymorphic association to any table 
# with the given identifier type. The first listed column is a VARCHAR column 
# holding the name of the class (for that row).
many-to-any =
  element many-to-any {
    attlist.many-to-any, meta-value*, column, column+
  }
attlist.many-to-any &= attribute id-type { text }
attlist.many-to-any &= attribute meta-type { text }?
# - default: Hibernate.CLASS
index-many-to-any =
  element index-many-to-any {
    attlist.index-many-to-any, column, column+
  }
attlist.index-many-to-any &= attribute id-type { text }
attlist.index-many-to-any &= attribute meta-type { text }?
# - default: Hibernate.CLASS
collection-id =
  element collection-id {
    attlist.collection-id, meta*, column*, generator
  }
attlist.collection-id &= attribute column { text }
attlist.collection-id &= attribute type { text }
attlist.collection-id &= attribute length { text }?
# Generators generate unique identifiers. The class attribute specifies a Java 
# class implementing an id generation algorithm.
generator = element generator { attlist.generator, param* }
attlist.generator &= attribute class { text }
param = element param { attlist.param, text }
attlist.param &= attribute name { text }
# The column element is an alternative to column attributes and required for 
# mapping associations to classes with composite ids.
column = element column { attlist.column, empty }
attlist.column &= attribute name { text }
attlist.column &= attribute length { text }?
# default: 255
attlist.column &= attribute not-null { "true" | "false" }?
# default: false (except for id properties)
attlist.column &= attribute unique { "true" | "false" }?
# default: false (except for id properties)
attlist.column &= attribute unique-key { text }?
# default: no unique key
attlist.column &= attribute sql-type { text }?
# override default column type for hibernate type
attlist.column &= attribute index { text }?
attlist.column &= attribute check { text }?
# default: none

# The cache or jcs-cache element enables caching of an entity class.
cache = element cache { attlist.cache, empty }
attlist.cache &=
  attribute usage {
    "read-only"
    | "read-write"
    | "nonstrict-read-write"
    | "transactional"
  }
jcs-cache = element jcs-cache { attlist.jcs-cache, empty }
attlist.jcs-cache &=
  attribute usage {
    "read-only"
    | "read-write"
    | "nonstrict-read-write"
    | "transactional"
  }
# deprecated

# The query element declares a named Hibernate query string
query = element query { attlist.query, text }
attlist.query &= attribute name { text }
# The sql-query element declares a named SQL query string
return = element return { attlist.return, empty }
attlist.return &= attribute alias { text }
attlist.return &= attribute class { text }
synchronize = element synchronize { attlist.synchronize, empty }
attlist.synchronize &= attribute table { text }
sql-query =
  element sql-query {
    attlist.sql-query, (text | return | synchronize)*
  }
attlist.sql-query &= attribute name { text }
# The meta element is used to assign meta-level attributes to a class or property.
# Is currently used by codegenerator as a placeholder for values that is not directly
# related to OR mappings.
meta = element meta { attlist.meta, text }
attlist.meta &= attribute attribute { text }
attlist.meta &=
  [ a:defaultValue = "true" ] attribute inherit { "true" | "false" }?
start = hibernate-mapping
